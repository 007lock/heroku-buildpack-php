#!/usr/bin/env bash

# fail hard
set -o pipefail
# fail harder
set -eu

export HEROKU_APP_DIR=`pwd`
# we need this in configs
export DOCUMENT_ROOT="$HEROKU_APP_DIR"
# set a default port if none is given
export PORT=${PORT:-$(( $RANDOM+1024 ))}

httpd_user_config=""
php="php-fpm --nodaemonize -y $HEROKU_APP_DIR/vendor/heroku/heroku-buildpack-php/conf/php/php-fpm.conf -c $HEROKU_APP_DIR/vendor/heroku/heroku-buildpack-php/conf/php/php.ini"
test=0
while getopts ":a:f:t" opt; do
    case $opt in
        a)
            if [[ -z $OPTARG ]]; then
                echo "Must give additional httpd.conf path (relative to '$HEROKU_APP_DIR')" >&2
                exit 1
            fi
            # FIXME: check if it exists
            httpd_user_config="Include $HEROKU_APP_DIR/$OPTARG"
            echo "Using additional Apache2 configuration file '$HEROKU_APP_DIR/$OPTARG'" >&2
            ;;
        f)
            if [[ -z $OPTARG ]]; then
                echo "Must give custom php-fpm.conf path (relative to '$HEROKU_APP_DIR')" >&2
                exit 1
            fi
            # FIXME: check if it exists
            php="$php -y $HEROKU_APP_DIR/$OPTARG" # can safely repeat to overwrite
            echo "Using custom PHP-FPM configuration file '$HEROKU_APP_DIR/$OPTARG'" >&2
            ;;
        i)
            if [[ -z $OPTARG ]]; then
                echo "Must give custom php.ini path (relative to '$HEROKU_APP_DIR')" >&2
                exit 1
            fi
            # FIXME: check if it exists
            php="$php -c $HEROKU_APP_DIR/$OPTARG" # can safely repeat to overwrite
            echo "Using custom PHP INI file '$HEROKU_APP_DIR/$OPTARG'" >&2
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            exit 1
            ;;
        :)
            echo "Option -$OPTARG requires an argument." >&2
            exit 1
            ;;
    esac
done
# clear processed arguments
shift $((OPTIND-1))

php -r 'exit((int)version_compare(PHP_VERSION, "5.5.11", "<"));' || { echo "This program requires PHP 5.5.11 or newer" >&2; exit 1; }
httpd -v | php -r 'exit((int)version_compare(preg_replace("#^Server version: Apache/([\d\\.]+).+$#sm", "\\1", file_get_contents("php://stdin")), "2.4.8", "<"));' || { echo "This program requires Apache 2.4.8 or newer with mod_proxy_fcgi enabled" >&2; exit 1; }

echo "Booting on port $PORT..." >&2

if [ "$#" == "1" ]; then
    # FIXME: check if it exists, strip trailing slashes
    DOCUMENT_ROOT="$HEROKU_APP_DIR/$1"
    echo "DOCUMENT_ROOT changed to '$DOCUMENT_ROOT'" >&2
fi

# make a shared pipe; we'll write the name of the process that exits to it once that happens, and wait for that event below
# this particular call works on Linux and Mac OS (will create a literal ".XXXXXX" on Mac, but that doesn't matter).
wait_pipe=`mktemp -t "heroku.waitpipe-$PORT.XXXXXX" -u`
rm -rf $wait_pipe
mkfifo $wait_pipe

# trap SIGINT/SIGQUIT (ctrl+c or ctrl+\ on the console), SIGTERM, and EXIT (upon failure of any command due to set -e, or because of the exit 1 at the very end), kill subshell child processes, then subshells
# 1) restore EXIT trap immediately, or the exit at the end of the line will trigger this trap again
# 2) kill childrens' child processes (the stuff running inside the sub-shells) using xargs because this is easier (-P expects a comma separated list); the || true prevents premature exit (set -e) if one of those doesn't have children anymore (it's likely that's why we're hitting this bit of code in the first place)
# 3) kill child processes (that's the sub-shells); it's likely that some of them have already disappeared, so xarg || true it too and suppress "no such process" complaints by sending them to /dev/null
# FIXME: this doesn't currently fire when the subshells themselves are terminated, and apparently also not when killing the tail command
# FIXME: when killing the httpd command or ctrl+c-ing, it leaves fpm behind, unlike with nginx, must investigate
# TODO: for extra brownie points, move to a function and curry for each given signal, passing the signal in as an arg, so we can use different exit codes or messages
trap 'trap - EXIT; echo "Going down, terminating child processes..." >&2; jobs -p | xargs -n1 pkill -TERM -P || true; jobs -p | xargs -n1 kill -TERM 2> /dev/null || true; exit' SIGINT SIGQUIT SIGTERM EXIT

# redirect logs to STDERR; write "tail ..." to the shared pipe if it exits
echo "Starting log redirection..." >&2
( touch "/tmp/heroku.php-fpm.$PORT.log" "/tmp/heroku.apache2_error.$PORT.log" "/tmp/heroku.apache2_access.$PORT.log"; tail -qF -n 0 /tmp/heroku.*.$PORT.log 1>&2; echo "tail heroku.*.$PORT.log"; ) > $wait_pipe &
# start FPM; write "php-fpm" to the shared pipe if it exits
echo "Starting php-fpm..." >&2
( $php; echo "php-fpm"; ) > $wait_pipe &
# FIXME: check for 2.4.8 or later
# start apache; write "httpd" to the shared pipe if it exits
echo "Starting httpd..." >&2
( httpd -D FOREGROUND -c "Include $HEROKU_APP_DIR/vendor/heroku/heroku-buildpack-php/conf/apache2/heroku.conf" -c "$httpd_user_config" || true; echo "httpd"; ) > $wait_pipe &

# wait for something to come from the shared pipe, which means that the given process was killed or has failed
# we'll only reach this if one of the processes above has terminated
read exitproc < $wait_pipe
echo "Process exited unexpectedly: $exitproc"

# this will trigger the trap and kill all remaining children
exit 1
